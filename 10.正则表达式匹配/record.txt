题目描述： 输入两个字符串，1串代表原始字符串s，1串代表正则表达式p，判断能否使用正则表达式表示原始字符串。
题目制定了两个字符：'.'代表任意以为字符。'c*'代表0至多个字符c。
					 
					 
初步思路：对于字符串的比较可以从右往左，问题的关键应该会在于处理*的情况下。
那么假设最右边的n-k的字符能够在表达式中最右边n-l个字符匹配。那么就是判断原串从0到k个字符能与0到l的正则表达式匹配。
那么现在就是要比较正则表达式中第i个字符能否表示原始子串中靠右的字符。
p[l]有三种情况：（1）为普通字符，（2）为. （3）为*
前两种情况直接比较s[k]就好了。第三种情况将会记录原子串中最右端的i个相同字符。再与p[l-1]比较是否相同
不同就无视。l左移2位。相同则要比较p[l-2]是否相同。相同的话l再左移比较p[l-3]，最多比较i个字符。
另外出现特例是.*的情况。（复杂）那么还有比前面的情况
					
改进方法：题目的标签是DP，所以使用动态规划来解决。同样是从右往左考虑。
构建2维数组 a[i][j]。表示原串的前i个字符可以有正则表达式的前j个字符表示。
状态转移方程就可以为：
p[j-1]不为*的情况下 a[i][j] = a[i-1][j-1] && (s[i]==p[j] || p[j] = '.' )  
p[j-1]为*的情况下：
(如果s[i] != p[j-2] 重复0次）   a[i][j] = a[i][j-2]    
(如果s[i] == p[j-2] 重复0次以上) a[i][j] = (a[i-1][j] || a[i][j-2])

					
					