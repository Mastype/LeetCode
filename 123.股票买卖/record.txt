121、121 简单。
121的题目要求是给定一数组，要求只能交易一回（一次买一次卖）求最大收益。 使用一个变量来记录前i个数的最小值变可以求得 O(n)
121的题目要求是给定一数组，可以交易任意次（一次只能持有一份）求最大收益。 那么只要求两日之间正差值之和就好了。。。

123
题目描述： 给定一数组，要求最多交易两次（一次只能持有一份）求最大收益。比如 1,3,1,5 得6 。1,2,3,4,5 得4。
					 
初步思路：使用DP方法首先求出记 min_prices[i][j]代表从i-j日最低的价格。记 max_profit[i][j]为 i-j日能获取的最大收益。
那么min_prices 的状态转移方程为  min_pri[i][j] = min(min_pri[i][j-1], prices[j]) max_profit的状态转移方程为  max_pro[i][j] = max( max_pro[i][j-1], prices[j] - min_pri[i][j] )
最后得到的结果即为 maxProfit = max( max_pro[0][size-1], max_pro[0][i]+max_pro[i][size-1])。
时间复杂度为O(n^2) 空间复杂度为 O(2*(size ^ 2))
因为两个矩阵都是三角矩阵。所以可以进行合并。 最后的空间复杂的可以为 O(size^2)
测试用例有10000维的样本。MLE
其实这之中有很多没有用的元素。所以仍可以进行优化
					
改进方法：
在解答中发现一个非常优秀的解答。思路是121题上的扩展，也是一个DP方法。其定义了一个2*4的数组。 stats[i%2][0] 代表一次买入。 stats[i%2][1]代表 1买1卖。 stats[i%2][2]代表 2买1卖。 stats[i%2][3]代表2买2卖。 return max(s[size%2][3],s[size%2][3])
stats[i%2][0] = max( stats[(i-1)%2][0], -prices[i]); 可以理解为买入一次的最高收益（最低开销）
stats[i%2][1] = max( stats[(i-1)%2][1], stats[(i-1)%2][0] + prices[i]);  可以理解为买入一次卖出一次的最高收益。
stats[i%2][2] = max( stats[(i-1)%2][2], stats[(i-1)%2][1] - prices[i]);  
stats[i%2][3] = max( stats[(i-1)%2][3], stats[(i-1)%2][2] + prices[i]); 
时间复杂度可以缩短至O(n)。空间复杂的为O(1)。
					
					